// command-api: gRPC CommandService — operator-facing bidirectional streaming command endpoint.
//
// Operators send commands via a persistent gRPC bidirectional stream:
//   - Single stream per operator session (HTTP/2 multiplexing, no per-command connection)
//   - Commands are published to NATS JetStream with UUIDv7 deduplication IDs
//   - ACKs from vehicles flow back through NATS → this service → the gRPC stream
//
// Exactly-once guarantee:
//   - command_id = UUIDv7 (monotonic, time-sortable, globally unique)
//   - NATS JetStream 2-minute dedup window on "command" stream
//   - If operator retries within 2 minutes, vehicle sees first delivery only
//
// Authorization (enforced at gRPC level, before NATS publish):
//   - JWT Bearer validated by shared/auth middleware
//   - vehicle_set claim: operator can only command vehicles in their set
//   - role claim: must be "operator" or "admin" to send commands
package main

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/google/uuid"
	"github.com/systemscale/services/shared/auth"
	"github.com/systemscale/services/shared/router"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// ──────────────────────────────────────────────────────────────────────────────
// Configuration
// ──────────────────────────────────────────────────────────────────────────────

type config struct {
	GRPCAddr     string
	HTTPRestAddr string
	NATSUrl      string
	JWKSUrl      string
	MetricsAddr  string
	RegionID     string
}

func loadConfig() config {
	return config{
		GRPCAddr:     envOr("GRPC_ADDR", ":50051"),
		HTTPRestAddr: envOr("HTTP_REST_ADDR", ":8082"),
		NATSUrl:      envOr("NATS_URL", "nats://localhost:4222"),
		JWKSUrl:      envOr("JWKS_URL", "https://keycloak.internal/realms/systemscale/protocol/openid-connect/certs"),
		MetricsAddr:  envOr("METRICS_ADDR", ":9090"),
		RegionID:     envOr("REGION_ID", "local"),
	}
}

// ──────────────────────────────────────────────────────────────────────────────
// Proto stubs (until buf generates the real code)
// These mirror proto/core/command_service.proto exactly.
// ──────────────────────────────────────────────────────────────────────────────

// CommandEnvelope mirrors proto/core/envelope.proto CommandEnvelope.
type CommandEnvelope struct {
	VehicleID  string // field 1
	CommandID  string // field 2 — UUIDv7, set by this service
	Payload    []byte // field 3 — opaque command bytes from operator
	Priority   int32  // field 4 — 0=NORMAL, 1=HIGH, 2=EMERGENCY
	TtlMs      uint32 // field 7 — discard if not delivered within TTL
}

// CommandAck mirrors proto/core/common.proto CommandAck.
type CommandAck struct {
	CommandID string // field 1
	VehicleID string // field 2
	Status    int32  // field 3 — 0=PENDING, 1=DELIVERED, 2=EXECUTED, 3=FAILED, 4=TIMEOUT
	Message   string // field 4 — human-readable status (from vehicle)
	LatencyMs uint32 // field 5 — round-trip latency from NATS publish to vehicle ACK
}

// encodeCommandEnvelope serializes CommandEnvelope to proto binary.
// Manual encoding matches the proto field numbers without code generation.
func encodeCommandEnvelope(cmd *CommandEnvelope) ([]byte, error) {
	// Use proto.Marshal with a generated type in production.
	// Manual encoding for now — matches field numbers in envelope.proto.
	var out []byte
	out = appendProtoString(out, 1, cmd.VehicleID)  // vehicle_id = 1
	out = appendProtoString(out, 2, cmd.CommandID)   // command_id = 2
	out = appendProtoBytes(out, 3, cmd.Payload)      // payload = 3
	out = appendProtoVarint(out, 4, uint64(cmd.Priority)) // priority = 4
	if cmd.TtlMs > 0 {
		out = appendProtoVarint(out, 7, uint64(cmd.TtlMs)) // ttl_ms = 7
	}
	return out, nil
}

// ──────────────────────────────────────────────────────────────────────────────
// CommandService implementation
// ──────────────────────────────────────────────────────────────────────────────

// CommandServiceServer implements the gRPC CommandService.
// The gRPC service definition (from proto) will be auto-generated by buf in production.
type CommandServiceServer struct {
	router   router.MessageRouter
	regionID string
}

// SendCommand handles a bidirectional streaming RPC.
// The operator sends CommandEnvelope messages; the server streams back CommandAck messages.
//
// Stream lifecycle:
//   1. Validate JWT (auth interceptor, already done before this method)
//   2. For each incoming command:
//      a. Authorize: check vehicle in operator's vehicle_set
//      b. Assign UUIDv7 command_id (dedup key)
//      c. Publish to NATS JetStream "command.{vehicle_id}" with Nats-Msg-Id header
//      d. Subscribe to "command.{vehicle_id}.ack" on NATS
//      e. When ACK arrives, stream CommandAck back to operator
func (s *CommandServiceServer) SendCommand(stream grpc.BidiStreamingServer[CommandEnvelope, CommandAck]) error {
	ctx := stream.Context()
	claims, ok := auth.ClaimsFromContext(ctx)
	if !ok {
		return status.Error(codes.Unauthenticated, "missing auth claims")
	}
	if !claims.Role.CanSendCommand() {
		return status.Error(codes.PermissionDenied, "role does not allow sending commands")
	}

	// Subscribe to ACK subjects for this operator's session.
	// We use a session-scoped channel to correlate ACKs with pending commands.
	pendingACKs := make(map[string]chan *CommandAck, 64) // command_id → ack channel
	var pendingMu sync.Mutex                             // guards pendingACKs

	// ACK subscriber: listens on command.*.ack and routes to the right pending channel
	// We subscribe to all ACKs and filter by command_id (simpler than per-vehicle subs)
	ackCh, err := s.router.Subscribe(ctx, "command.>.ack")
	if err != nil {
		return status.Errorf(codes.Internal, "subscribe ACK: %v", err)
	}

	// Background ACK router: receives ACKs from NATS and routes to pending channels
	go func() {
		for msg := range ackCh {
			ack, err := decodeCommandAck(msg.Data)
			if err != nil {
				slog.Warn("ACK decode error", "err", err)
				continue
			}
			pendingMu.Lock()
			ch, ok := pendingACKs[ack.CommandID]
			pendingMu.Unlock()
			if ok {
				select {
				case ch <- ack:
				default:
					// Operator is slow consuming ACKs — drop this one
				}
			}
		}
	}()

	// Command receive loop
	for {
		cmd, err := stream.Recv()
		if err != nil {
			return nil // stream closed by operator
		}

		// Authorization check
		if !claims.CanAccessVehicle(cmd.VehicleID) {
			if err := stream.Send(&CommandAck{
				CommandID: cmd.CommandID,
				VehicleID: cmd.VehicleID,
				Status:    3, // FAILED
				Message:   "not authorized for this vehicle",
			}); err != nil {
				return err
			}
			continue
		}

		// Assign UUIDv7 command_id (time-sortable, globally unique, used for NATS dedup)
		cmd.CommandID = uuid.Must(uuid.NewV7()).String()

		// Encode and publish to NATS JetStream with deduplication header
		payload, err := encodeCommandEnvelope(cmd)
		if err != nil {
			slog.Error("encode command", "err", err)
			continue
		}

		subject := fmt.Sprintf("command.%s", cmd.VehicleID)
		pubErr := s.router.Publish(ctx, subject, payload, router.PubOptions{
			DeduplicationID: cmd.CommandID, // Nats-Msg-Id → exactly-once within 2min window
			TTL:             30 * time.Second,
		})
		if pubErr != nil {
			slog.Error("NATS publish command", "err", pubErr, "vehicle", cmd.VehicleID)
			stream.Send(&CommandAck{
				CommandID: cmd.CommandID,
				VehicleID: cmd.VehicleID,
				Status:    3, // FAILED
				Message:   fmt.Sprintf("publish error: %v", pubErr),
			})
			continue
		}

		// Register pending ACK channel
		ackChan := make(chan *CommandAck, 1)
		pendingMu.Lock()
		pendingACKs[cmd.CommandID] = ackChan
		pendingMu.Unlock()

		// ACK timeout goroutine
		go func(commandID, vehicleID string) {
			ttl := 30 * time.Second
			if cmd.TtlMs > 0 {
				ttl = time.Duration(cmd.TtlMs) * time.Millisecond
			}
			select {
			case ack := <-ackChan:
				pendingMu.Lock()
				delete(pendingACKs, commandID)
				pendingMu.Unlock()
				if sendErr := stream.Send(ack); sendErr != nil {
					slog.Warn("stream send ACK", "err", sendErr)
				}
			case <-time.After(ttl):
				pendingMu.Lock()
				delete(pendingACKs, commandID)
				pendingMu.Unlock()
				stream.Send(&CommandAck{
					CommandID: commandID,
					VehicleID: vehicleID,
					Status:    4, // TIMEOUT
					Message:   "vehicle did not ACK within TTL",
				})
			case <-ctx.Done():
			}
		}(cmd.CommandID, cmd.VehicleID)

		slog.Info("command published",
			"command_id", cmd.CommandID,
			"vehicle_id", cmd.VehicleID,
			"priority", cmd.Priority,
		)
	}
}

// decodeCommandAck parses a raw ACK protobuf payload from NATS.
// Mirrors CommandAck in proto/core/common.proto field numbers.
func decodeCommandAck(data []byte) (*CommandAck, error) {
	ack := &CommandAck{}
	var pos int
	for pos < len(data) {
		tag, n := consumeVarint(data[pos:])
		if n == 0 {
			break
		}
		pos += n
		fieldNum := tag >> 3
		wireType := tag & 0x7
		switch wireType {
		case 0:
			val, n2 := consumeVarint(data[pos:])
			if n2 == 0 {
				return nil, fmt.Errorf("truncated varint")
			}
			pos += n2
			switch fieldNum {
			case 3:
				ack.Status = int32(val)
			case 5:
				ack.LatencyMs = uint32(val)
			}
		case 2:
			length, n2 := consumeVarint(data[pos:])
			if n2 == 0 {
				return nil, fmt.Errorf("truncated length")
			}
			pos += n2
			s := string(data[pos : pos+int(length)])
			switch fieldNum {
			case 1:
				ack.CommandID = s
			case 2:
				ack.VehicleID = s
			case 4:
				ack.Message = s
			}
			pos += int(length)
		default:
			return nil, fmt.Errorf("unsupported wire type %d", wireType)
		}
	}
	return ack, nil
}

// ──────────────────────────────────────────────────────────────────────────────
// HTTP REST wrapper (:8082) — browsers cannot use raw gRPC
// ──────────────────────────────────────────────────────────────────────────────

var commandStatusNames = map[int32]string{
	0: "pending",
	1: "delivered",
	2: "completed",
	3: "failed",
	4: "timeout",
}

type ackEntry struct {
	CommandID  string    `json:"command_id"`
	VehicleID  string    `json:"vehicle_id"`
	Status     string    `json:"status"`
	Message    string    `json:"message"`
	LatencyMs  uint32    `json:"latency_ms"`
	receivedAt time.Time // for expiry — not JSON-exported
}

type restServer struct {
	msgRouter router.MessageRouter
	validator *auth.Validator
	mu        sync.RWMutex
	acks      map[string]*ackEntry          // command_id → ack
	waiters   map[string][]chan *ackEntry   // command_id → SSE waiters
}

func newRestServer(msgRouter router.MessageRouter, validator *auth.Validator) *restServer {
	return &restServer{
		msgRouter: msgRouter,
		validator: validator,
		acks:      make(map[string]*ackEntry),
		waiters:   make(map[string][]chan *ackEntry),
	}
}

// startACKListener subscribes to command.*.ack and populates the ACK map.
// ACKs are kept for 5 minutes then expired by a background ticker.
func (rs *restServer) startACKListener(ctx context.Context) error {
	ackCh, err := rs.msgRouter.Subscribe(ctx, "command.>.ack")
	if err != nil {
		return fmt.Errorf("subscribe ACK: %w", err)
	}

	// Expiry ticker — runs every minute, removes entries older than 5 minutes
	go func() {
		ticker := time.NewTicker(time.Minute)
		defer ticker.Stop()
		for {
			select {
			case <-ticker.C:
				cutoff := time.Now().Add(-5 * time.Minute)
				rs.mu.Lock()
				for id, e := range rs.acks {
					if e.receivedAt.Before(cutoff) {
						delete(rs.acks, id)
					}
				}
				rs.mu.Unlock()
			case <-ctx.Done():
				return
			}
		}
	}()

	// ACK consumer
	go func() {
		for msg := range ackCh {
			ack, err := decodeCommandAck(msg.Data)
			if err != nil {
				slog.Warn("REST ACK decode", "err", err)
				continue
			}
			statusStr := commandStatusNames[ack.Status]
			if statusStr == "" {
				statusStr = "unknown"
			}
			entry := &ackEntry{
				CommandID:  ack.CommandID,
				VehicleID:  ack.VehicleID,
				Status:     statusStr,
				Message:    ack.Message,
				LatencyMs:  ack.LatencyMs,
				receivedAt: time.Now(),
			}
			rs.mu.Lock()
			rs.acks[ack.CommandID] = entry
			// Notify any SSE waiters immediately — no more polling needed
			for _, ch := range rs.waiters[ack.CommandID] {
				select {
				case ch <- entry:
				default:
				}
			}
			delete(rs.waiters, ack.CommandID)
			rs.mu.Unlock()
		}
	}()

	return nil
}

// POST /v1/commands
// Body: {"vehicle_id","command_type","payload_b64","priority","ttl_ms"}
func (rs *restServer) handleSendCommand(w http.ResponseWriter, r *http.Request) {
	claims, ok := auth.ClaimsFromContext(r.Context())
	if !ok {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}
	if !claims.Role.CanSendCommand() {
		http.Error(w, "Forbidden: operator or admin role required", http.StatusForbidden)
		return
	}

	var req struct {
		VehicleID   string `json:"vehicle_id"`
		CommandType string `json:"command_type"`
		PayloadB64  string `json:"payload_b64"`
		Priority    int32  `json:"priority"`
		TtlMs       uint32 `json:"ttl_ms"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.VehicleID == "" {
		http.Error(w, "Bad Request: vehicle_id required", http.StatusBadRequest)
		return
	}

	if !claims.CanAccessVehicle(req.VehicleID) {
		http.Error(w, "Forbidden: vehicle not in vehicle_set", http.StatusForbidden)
		return
	}

	var payload []byte
	if req.PayloadB64 != "" {
		var err error
		payload, err = base64.StdEncoding.DecodeString(req.PayloadB64)
		if err != nil {
			http.Error(w, "Bad Request: invalid payload_b64", http.StatusBadRequest)
			return
		}
	} else if req.CommandType != "" {
		// Encode command_type as a simple JSON payload if no binary payload given
		payload, _ = json.Marshal(map[string]string{"type": req.CommandType})
	}

	commandID := uuid.Must(uuid.NewV7()).String()
	cmd := &CommandEnvelope{
		VehicleID: req.VehicleID,
		CommandID: commandID,
		Payload:   payload,
		Priority:  req.Priority,
		TtlMs:     req.TtlMs,
	}

	encoded, err := encodeCommandEnvelope(cmd)
	if err != nil {
		slog.Error("REST encode command", "err", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	subject := fmt.Sprintf("command.%s", req.VehicleID)
	if err := rs.msgRouter.Publish(r.Context(), subject, encoded, router.PubOptions{
		DeduplicationID: commandID,
		TTL:             30 * time.Second,
	}); err != nil {
		slog.Error("REST NATS publish", "err", err, "vehicle", req.VehicleID)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	slog.Info("REST command queued", "command_id", commandID, "vehicle_id", req.VehicleID)
	writeJSON(w, http.StatusAccepted, map[string]string{
		"command_id": commandID,
		"status":     "queued",
	})
}

// GET /v1/commands/{id}/stream — SSE push; resolves as soon as the ACK lands.
// The SDK connects here instead of polling GET /v1/commands/{id} every 500ms.
func (rs *restServer) handleCommandStream(w http.ResponseWriter, r *http.Request) {
	_, ok := auth.ClaimsFromContext(r.Context())
	if !ok {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	// Parse command ID — strip prefix and "/stream" suffix
	commandID := strings.TrimPrefix(r.URL.Path, "/v1/commands/")
	commandID = strings.TrimSuffix(commandID, "/stream")
	if commandID == "" {
		http.Error(w, "Bad Request: missing command ID", http.StatusBadRequest)
		return
	}

	flusher, ok := w.(http.Flusher)
	if !ok {
		http.Error(w, "Streaming not supported", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	// Check for an existing ACK and register the waiter atomically under a single
	// write lock — eliminates the window where an ACK could arrive between an
	// RUnlock and the subsequent Lock, causing the SSE client to hang forever.
	ch := make(chan *ackEntry, 1)
	rs.mu.Lock()
	if entry, found := rs.acks[commandID]; found {
		rs.mu.Unlock()
		b, _ := json.Marshal(entry)
		fmt.Fprintf(w, "data: %s\n\n", b)
		flusher.Flush()
		return
	}
	rs.waiters[commandID] = append(rs.waiters[commandID], ch)
	rs.mu.Unlock()

	defer func() {
		rs.mu.Lock()
		wlist := rs.waiters[commandID]
		for i, c := range wlist {
			if c == ch {
				rs.waiters[commandID] = append(wlist[:i], wlist[i+1:]...)
				break
			}
		}
		rs.mu.Unlock()
	}()

	select {
	case entry := <-ch:
		b, _ := json.Marshal(entry)
		fmt.Fprintf(w, "data: %s\n\n", b)
		flusher.Flush()
	case <-r.Context().Done():
		// client disconnected or TTL timeout — caller gets "timeout" from its own deadline
	}
}

// GET /v1/commands/{id}
func (rs *restServer) handleGetCommand(w http.ResponseWriter, r *http.Request) {
	_, ok := auth.ClaimsFromContext(r.Context())
	if !ok {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	commandID := strings.TrimPrefix(r.URL.Path, "/v1/commands/")
	if commandID == "" {
		http.Error(w, "Bad Request: missing command ID", http.StatusBadRequest)
		return
	}

	rs.mu.RLock()
	entry, found := rs.acks[commandID]
	rs.mu.RUnlock()

	if !found {
		writeJSON(w, http.StatusOK, map[string]string{
			"command_id": commandID,
			"status":     "pending",
		})
		return
	}
	writeJSON(w, http.StatusOK, entry)
}

func (rs *restServer) routes() http.Handler {
	mux := http.NewServeMux()
	protect := auth.HTTPMiddleware(rs.validator)

	mux.Handle("/v1/commands", protect(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method == http.MethodPost {
			rs.handleSendCommand(w, r)
		} else {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		}
	})))

	mux.Handle("/v1/commands/", protect(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodGet {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}
		if strings.HasSuffix(r.URL.Path, "/stream") {
			rs.handleCommandStream(w, r)
		} else {
			rs.handleGetCommand(w, r)
		}
	})))

	mux.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "ok")
	})

	return corsMiddleware(mux)
}

func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := os.Getenv("CORS_ALLOW_ORIGIN")
		if origin == "" {
			origin = "*"
		}
		w.Header().Set("Access-Control-Allow-Origin", origin)
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusNoContent)
			return
		}
		next.ServeHTTP(w, r)
	})
}

func writeJSON(w http.ResponseWriter, code int, v interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(v)
}

// ──────────────────────────────────────────────────────────────────────────────
// gRPC server setup
// ──────────────────────────────────────────────────────────────────────────────

func main() {
	slog.SetDefault(slog.New(slog.NewJSONHandler(os.Stdout, nil)))
	cfg := loadConfig()
	slog.Info("Starting command-api", "addr", cfg.GRPCAddr, "region", cfg.RegionID)

	// Auth validator (JWKS from Keycloak)
	validator, err := auth.NewValidator(cfg.JWKSUrl)
	if err != nil {
		slog.Error("auth validator init", "err", err)
		os.Exit(1)
	}

	// NATS router
	msgRouter, err := router.NewNATSRouter(cfg.NATSUrl, "command-api")
	if err != nil {
		slog.Error("NATS connect", "err", err)
		os.Exit(1)
	}
	defer msgRouter.Close()

	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)
	defer cancel()

	// HTTP REST server — browsers cannot use raw gRPC
	rest := newRestServer(msgRouter, validator)
	if err := rest.startACKListener(ctx); err != nil {
		slog.Error("REST ACK listener", "err", err)
		os.Exit(1)
	}
	httpServer := &http.Server{
		Addr:         cfg.HTTPRestAddr,
		Handler:      rest.routes(),
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}
	go func() {
		slog.Info("command-api REST server ready", "addr", cfg.HTTPRestAddr)
		if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("REST serve error", "err", err)
		}
	}()

	// gRPC server with auth interceptors
	grpcServer := grpc.NewServer(
		grpc.UnaryInterceptor(auth.GRPCUnaryInterceptor(validator)),
		grpc.StreamInterceptor(auth.GRPCStreamInterceptor(validator)),
		// Max message size: 4MB (large enough for any command payload)
		grpc.MaxRecvMsgSize(4*1024*1024),
		grpc.MaxSendMsgSize(4*1024*1024),
	)

	// Register CommandService
	// In production: use generated registration from buf output
	// grpcpb.RegisterCommandServiceServer(grpcServer, &CommandServiceServer{...})
	_ = &CommandServiceServer{router: msgRouter, regionID: cfg.RegionID}

	lis, err := net.Listen("tcp", cfg.GRPCAddr)
	if err != nil {
		slog.Error("listen failed", "addr", cfg.GRPCAddr, "err", err)
		os.Exit(1)
	}

	go func() {
		<-ctx.Done()
		slog.Info("Graceful shutdown initiated")
		grpcServer.GracefulStop()
		shutCtx, shutCancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer shutCancel()
		httpServer.Shutdown(shutCtx)
	}()

	slog.Info("command-api gRPC server ready", "addr", cfg.GRPCAddr)
	if err := grpcServer.Serve(lis); err != nil {
		slog.Error("gRPC serve error", "err", err)
	}
}

// ──────────────────────────────────────────────────────────────────────────────
// Proto encoding helpers (manual, matches generated prost output)
// ──────────────────────────────────────────────────────────────────────────────

func appendProtoVarint(out []byte, fieldNum uint32, val uint64) []byte {
	out = appendVarint(out, uint64(fieldNum<<3|0)) // wire type 0
	return appendVarint(out, val)
}

func appendProtoString(out []byte, fieldNum uint32, s string) []byte {
	out = appendVarint(out, uint64(fieldNum<<3|2)) // wire type 2
	out = appendVarint(out, uint64(len(s)))
	return append(out, s...)
}

func appendProtoBytes(out []byte, fieldNum uint32, b []byte) []byte {
	out = appendVarint(out, uint64(fieldNum<<3|2)) // wire type 2
	out = appendVarint(out, uint64(len(b)))
	return append(out, b...)
}

func appendVarint(out []byte, v uint64) []byte {
	for v >= 0x80 {
		out = append(out, byte(v)|0x80)
		v >>= 7
	}
	return append(out, byte(v))
}

func consumeVarint(data []byte) (uint64, int) {
	var result uint64
	for i, b := range data {
		result |= uint64(b&0x7F) << (7 * uint(i))
		if b&0x80 == 0 {
			return result, i + 1
		}
		if i >= 9 {
			return 0, 0
		}
	}
	return 0, 0
}

func envOr(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

